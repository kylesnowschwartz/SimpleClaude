import VertexClient from './VertexClient.js';
import { validateEnvironment } from './utils.js';
import mlDistance from 'ml-distance';
const { cosine } = mlDistance.similarity;

class AssetMetadataEvaluator {
  constructor(jsonSchema) {
    validateEnvironment([
      'TEXT_EVALUATION_MODEL_ID',
      'MAX_CONCURRENT_VIDEOS'
    ]);
    
    // Initialize Vertex client with text evaluation model
    this.vertexClient = new VertexClient(process.env.TEXT_EVALUATION_MODEL_ID);
    
    this.schema = jsonSchema;
  }

  // Infer evaluation type from JSON Schema type
  inferEvaluationType(fieldSchema, fullFieldName) {
    const type = fieldSchema.type;
    
    // TODO: make generic
    if (fullFieldName === 'metadata.keywords') return 'array+similarity'

    if (type === 'boolean') return 'boolean';
    if (type === 'integer') return 'count';
    if (type === 'array') return 'multi-enum';
    if (type === 'string') {
      // Default string handling - check if it has enum values
      if (fieldSchema.enum) return 'single-enum';
      return 'text-similarity'; // Default for free text
    }
    
    return 'unknown';
  }

  // Get all evaluable fields from schema
  extractFields(properties, prefix = '') {
    const fields = {};
    
    for (const [fieldName, fieldSchema] of Object.entries(properties)) {
      const fullFieldName = prefix ? `${prefix}.${fieldName}` : fieldName;
      
      if (fieldSchema.type === 'object' && fieldSchema.properties) {
        // Recurse into nested objects
        Object.assign(fields, this.extractFields(fieldSchema.properties, fullFieldName));
      } else {
        // This is a leaf field
        fields[fullFieldName] = {
          schema: fieldSchema,
          type: this.inferEvaluationType(fieldSchema, fullFieldName)
        };
      }
    }
    
    return fields;
  }

  // Get field value from object using dot notation (handles both nested objects and flat dotted keys)
  getFieldValue(obj, fieldPath) {
    // First try direct access with dotted key (for flattened data)
    if (obj[fieldPath] !== undefined) {
      return obj[fieldPath];
    }
    
    // Fall back to nested access (for hierarchical data)
    return fieldPath.split('.').reduce((current, key) => {
      return current && current[key] !== undefined ? current[key] : null;
    }, obj);
  }

  // Exact match for simple types
  evaluateExactMatch(golden, generated) {
    if (Array.isArray(golden) && Array.isArray(generated)) {
      // For arrays, sort and compare
      const goldenSorted = [...golden].sort();
      const generatedSorted = [...generated].sort();
      return JSON.stringify(goldenSorted) === JSON.stringify(generatedSorted);
    }
    return golden === generated;
  }

  // Precision/Recall/F1 for multi-value fields
  evaluateMultiEnum(golden, generated) {
    const goldenArray = Array.isArray(golden) ? golden : [];
    const generatedArray = Array.isArray(generated) ? generated : [];
    
    const goldenSet = new Set(goldenArray);
    const generatedSet = new Set(generatedArray);
    
    const intersection = new Set([...goldenSet].filter(x => generatedSet.has(x)));
    const extra = [...generatedSet].filter(x => !goldenSet.has(x));
    const missing = [...goldenSet].filter(x => !generatedSet.has(x));
    
    const precision = generatedSet.size === 0 ? 0 : intersection.size / generatedSet.size;
    const recall = goldenSet.size === 0 ? (generatedSet.size === 0 ? 1 : 0) : intersection.size / goldenSet.size;
    const f1 = (precision + recall) === 0 ? 0 : (2 * precision * recall) / (precision + recall);
    
    return {
      match: this.evaluateExactMatch(goldenArray, generatedArray),
      precision: precision * 100,
      recall: recall * 100,
      f1: f1 * 100,
      extra,
      missing
    };
  }

  // Calculate embedding-based similarity using cosine similarity
  async calculateEmbeddingSimilarity(golden, generated) {
    try {
      const embeddings = await this.vertexClient.getEmbeddings([golden, generated]);
      
      if (embeddings.length !== 2) {
        console.error('Failed to get embeddings for both texts');
        return 0.0;
      }
      
      // Calculate cosine similarity (returns value between 0 and 1)
      // Return similarity directly (1 means identical, 0 means no similarity)
      return cosine(embeddings[0], embeddings[1]);
      
    } catch (error) {
      console.error('Error calculating embedding similarity:', error.message);
      return 0.0;
    }
  }

  // LLM-based similarity (existing method)
  async calculateLlmSimilarity(golden, generated) {
    try {
      const prompt = `
Compare these two texts and return a similarity percentage (0-100):

Golden Text: "${golden}"
Generated Text: "${generated}"

Consider semantic meaning, not just word overlap. Return only a number between 0 and 100.
      `.trim();

      // Build request payload for similarity evaluation
      const requestPayload = this.vertexClient.buildTextRequest(prompt, 0.1, 50);

      // Make API call through vertex client
      const responseText = await this.vertexClient.generateContent(requestPayload);
      
      const similarity = parseFloat(responseText);
      
      return isNaN(similarity) ? 0 : Math.min(100, Math.max(0, similarity));
      
    } catch (error) {
      console.error('Error calculating LLM similarity:', error.message);
      return 0;
    }
  }

  // Combined similarity evaluation
  async evaluateTextSimilarity(golden, generated) {
    const [llmSimilarity, embeddingSimilarity] = await Promise.all([
      this.calculateLlmSimilarity(golden, generated),
      this.calculateEmbeddingSimilarity(golden, generated)
    ]);
    
    return {
      llm: llmSimilarity,
      embedding: embeddingSimilarity * 100, // Convert to percentage
      combined: (llmSimilarity + embeddingSimilarity * 100) / 2
    };
  }

  // Evaluate a single field
  async evaluateField(fieldName, fieldInfo, golden, generated, overrideType = null) {
    const evaluationType = overrideType || fieldInfo.type;
    
    const result = {
      field: fieldName,
      type: evaluationType,
      golden_value: golden,
      generated_value: generated
    };

    switch (evaluationType) {
      case 'boolean':
      case 'count':
      case 'single-enum':
        result.match = this.evaluateExactMatch(golden, generated);
        break;
        
      case 'multi-enum':
        const multiResult = this.evaluateMultiEnum(golden, generated);
        Object.assign(result, multiResult);
        break;
        
      case 'text-similarity':
        result.similarity = await this.evaluateTextSimilarity(golden, generated);
        break;
        
      case 'array+similarity':
        // Both multi-enum evaluation AND similarity
        const arrayResult = this.evaluateMultiEnum(golden, generated);
        Object.assign(result, arrayResult);
        
        // Convert arrays to strings for similarity comparison
        const goldenText = Array.isArray(golden) ? golden.join(', ') : String(golden);
        const generatedText = Array.isArray(generated) ? generated.join(', ') : String(generated);
        result.similarity = await this.evaluateTextSimilarity(goldenText, generatedText);
        break;
    }

    return result;
  }

  // Evaluate a single asset
  async evaluateAsset(gcsUri, goldenData, generatedData) {
    console.log(`Evaluating asset: ${gcsUri}`);
    
    // Extract all evaluable fields from schema
    const fields = this.extractFields(this.schema.properties);
    
    const maxConcurrent = parseInt(process.env.MAX_CONCURRENT_VIDEOS) || 5;
    const fieldEntries = Object.entries(fields);
    const fieldResults = new Array(fieldEntries.length);
    const promises = [];
    
    // Evaluate fields in parallel batches
    for (let i = 0; i < fieldEntries.length; i++) {
      const [fieldName, fieldInfo] = fieldEntries[i];
      const golden = this.getFieldValue(goldenData, fieldName);
      const generated = this.getFieldValue(generatedData, fieldName);
      
      const promise = this.evaluateField(fieldName, fieldInfo, golden, generated)
        .then(result => {
          fieldResults[i] = result;
          return result;
        });
      
      promises.push(promise);
      
      if (promises.length >= maxConcurrent || i === fieldEntries.length - 1) {
        await Promise.all(promises);
        promises.length = 0;
        
        if (i < fieldEntries.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
    }
    
    return {
      gcs_uri: gcsUri,
      fields: fieldResults,
      timestamp: new Date().toISOString()
    };
  }

  // Generate summary statistics across all assets
  generateSummary(allAssetResults) {
    if (allAssetResults.length === 0) return [];
    
    const summary = {};
    
    // Initialize summary structure from first asset result
    const firstAssetFields = allAssetResults[0].fields;
    for (const fieldResult of firstAssetFields) {
      summary[fieldResult.field] = {
        field: fieldResult.field,
        type: fieldResult.type,
        total_videos: allAssetResults.length, // Keep this name for compatibility with existing display code
        exact_matches: 0,
        match_rate: 0,
        avg_precision: null,
        avg_recall: null,
        avg_f1: null,
        avg_llm_similarity: null,
        avg_embedding_similarity: null,
        avg_combined_similarity: null
      };
    }
    
    // Accumulate statistics
    for (const assetResult of allAssetResults) {
      for (const fieldResult of assetResult.fields) {
        const fieldName = fieldResult.field;
        const fieldSummary = summary[fieldName];
        
        // Count exact matches
        if (fieldResult.match === true) {
          fieldSummary.exact_matches++;
        }
        
        // Accumulate averages for multi-enum fields
        if (fieldResult.precision !== undefined) {
          if (fieldSummary.avg_precision === null) fieldSummary.avg_precision = 0;
          if (fieldSummary.avg_recall === null) fieldSummary.avg_recall = 0;
          if (fieldSummary.avg_f1 === null) fieldSummary.avg_f1 = 0;
          
          fieldSummary.avg_precision += fieldResult.precision;
          fieldSummary.avg_recall += fieldResult.recall;
          fieldSummary.avg_f1 += fieldResult.f1;
        }
        
        // Accumulate averages for text fields
        if (fieldResult.similarity !== undefined) {
          if (typeof fieldResult.similarity === 'object') {
            // New structure with llm, embedding, combined properties
            if (fieldSummary.avg_llm_similarity === null) fieldSummary.avg_llm_similarity = 0;
            if (fieldSummary.avg_embedding_similarity === null) fieldSummary.avg_embedding_similarity = 0;
            if (fieldSummary.avg_combined_similarity === null) fieldSummary.avg_combined_similarity = 0;
            
            fieldSummary.avg_llm_similarity += fieldResult.similarity.llm || 0;
            fieldSummary.avg_embedding_similarity += fieldResult.similarity.embedding || 0;
            fieldSummary.avg_combined_similarity += fieldResult.similarity.combined || 0;
          } else {
            // Legacy structure with single similarity value
            if (fieldSummary.avg_combined_similarity === null) fieldSummary.avg_combined_similarity = 0;
            fieldSummary.avg_combined_similarity += fieldResult.similarity;
          }
        }
      }
    }
    
    // Calculate final averages
    for (const fieldSummary of Object.values(summary)) {
      fieldSummary.match_rate = (fieldSummary.exact_matches / fieldSummary.total_videos) * 100;
      
      if (fieldSummary.avg_precision !== null) {
        fieldSummary.avg_precision /= fieldSummary.total_videos;
        fieldSummary.avg_recall /= fieldSummary.total_videos;
        fieldSummary.avg_f1 /= fieldSummary.total_videos;
      }
      
      if (fieldSummary.avg_llm_similarity !== null) {
        fieldSummary.avg_llm_similarity /= fieldSummary.total_videos;
      }
      if (fieldSummary.avg_embedding_similarity !== null) {
        fieldSummary.avg_embedding_similarity /= fieldSummary.total_videos;
      }
      if (fieldSummary.avg_combined_similarity !== null) {
        fieldSummary.avg_combined_similarity /= fieldSummary.total_videos;
      }
    }
    
    return Object.values(summary);
  }
}

export default AssetMetadataEvaluator;